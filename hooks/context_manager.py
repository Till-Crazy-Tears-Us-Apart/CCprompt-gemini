#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@FileName    : context_manager.py
@Description : Automated context persistence and restoration system.
               - PreCompact: Generates .compact_args.md snapshot automatically.
               - SessionStart: Injects .compact_args.md content into new sessions.
@Author      : Till-Crazy-Tears-Us-Apart
@CreationDate: 2026-01-10
"""

import sys
import json
import os
import subprocess
from datetime import datetime

SNAPSHOT_FILE = ".compact_args.md"

def generate_snapshot(cwd):
    """
    Generates the snapshot file using git status and file listings.
    Replicates the logic of the original /prepare-compact command.
    """
    try:
        # 1. Capture Git Status
        # Check if inside git tree
        git_check = subprocess.run(["git", "rev-parse", "--is-inside-work-tree"], cwd=cwd, capture_output=True)

        if git_check.returncode == 0:
            status_output = subprocess.run(["git", "status", "--short"], cwd=cwd, capture_output=True, encoding='utf-8', errors='replace').stdout
        else:
            status_output = "--- Project File Structure (Not a Git Repo) ---\n"
            # Fallback to listing files (max depth 2)
            try:
                # Use simple find command compatible with most unixes, or simple walk in python if needed.
                # Here we simulate 'find . -maxdepth 2' using python to be safe across OS
                file_list = []
                for root, dirs, files in os.walk(cwd):
                    depth = root[len(cwd):].count(os.sep)
                    if depth < 2:
                        for f in files:
                            file_list.append(os.path.join(root, f))
                status_output += "\n".join(file_list[:50]) # Limit to 50 files to prevent bloat
            except Exception as e:
                status_output += f"Error listing files: {e}"

        # 2. Generate Content
        # Dynamic Reading List Generation
        reading_list = []

        # Check for core docs
        if os.path.exists(os.path.join(cwd, "CLAUDE.md")):
            reading_list.append("- `CLAUDE.md` (System Instructions)")
        if os.path.exists(os.path.join(cwd, "README.md")):
            reading_list.append("- `README.md` (Project Overview)")

        # Scan for project directories (exclude hidden)
        try:
            dirs = [d for d in os.listdir(cwd)
                   if os.path.isdir(os.path.join(cwd, d)) and not d.startswith('.')]
            if dirs:
                dir_list = ", ".join([f"`{d}/`" for d in sorted(dirs)])
                reading_list.append(f"- Project Structure: {dir_list}")
        except Exception:
            pass

        reading_list_str = "\n".join(reading_list)

        content = f"""---
# Automated Context Snapshot
# Generated: {datetime.now().isoformat()}
---

## 1. Project State Snapshot
```
{status_output.strip()}
```

## 2. Context Restoration Protocol
(Auto-generated by context_manager.py)

**Required Reading List**:
{reading_list_str}
- **Focus**: Files listed in 'Project State Snapshot' above

**Next Action**:
The session has been compacted or restarted.
1. Review the file status above.
2. Read the necessary documentation and code files mentioned in the Protocol.
3. Await user instructions.
"""

        # 3. Write File
        with open(os.path.join(cwd, SNAPSHOT_FILE), 'w', encoding='utf-8') as f:
            f.write(content)

        print(f"Snapshot generated at {SNAPSHOT_FILE}", file=sys.stderr)

    except Exception as e:
        print(f"Failed to generate snapshot: {e}", file=sys.stderr)

def inject_context(cwd):
    """
    Reads the snapshot file and returns it for injection.
    """
    snapshot_path = os.path.join(cwd, SNAPSHOT_FILE)
    if os.path.exists(snapshot_path):
        try:
            with open(snapshot_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Return structured JSON for SessionStart
            output = {
                "hookSpecificOutput": {
                    "hookEventName": "SessionStart",
                    "additionalContext": f"\n\n=== AUTOMATED CONTEXT RESTORED FROM {SNAPSHOT_FILE} ===\n{content}\n===============================================\n"
                }
            }
            print(json.dumps(output))
        except Exception as e:
            # If read fails, just print error to stderr
            print(f"Error reading snapshot: {e}", file=sys.stderr)
            sys.exit(0)
    else:
        # No snapshot exists, do nothing
        sys.exit(0)

def main():
    sys.stdout.reconfigure(encoding='utf-8')
    try:
        input_data = json.load(sys.stdin)
        event_name = input_data.get("hook_event_name", "")
        cwd = input_data.get("cwd", os.getcwd())

        if event_name == "PreCompact":
            generate_snapshot(cwd)
            sys.exit(0) # Always continue compaction

        elif event_name == "SessionStart":
            inject_context(cwd)
            sys.exit(0)

        else:
            sys.exit(0)

    except Exception as e:
        print(f"Error in context_manager.py: {e}", file=sys.stderr)
        sys.exit(0)

if __name__ == "__main__":
    main()
